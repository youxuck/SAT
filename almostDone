#include <iostream>
#include <vector>
#include <string>
#include <chrono>
#include <thread>
#include <windows.h>
#include <cstdlib>
#include <ctime>
#include <conio.h>
#include <algorithm> 

using namespace std;

static const int W = 10; // 보드 가로
static const int H = 20; // 보드 세로

// 테트리스 7종 조각
const vector<vector<string>> SHAPES = {
    { "....", "####", "....", "...." }, // I
    { ".##.", ".##.", "....", "...." }, // O
    { "....", ".###", "..#.", "...." }, // T
    { "....", "..##", ".##.", "...." }, // S
    { "....", ".##.", "..##", "...." }, // Z
    { "....", ".###", ".#..", "...." }, // J
    { "....", ".###", "...#", "...." }  // L
};

class Piece {
public:
    int x, y;
    int type;
    int rot;
    int size = 4;

    Piece(int t = 0) : x(W / 2 - 2), y(0), type(t), rot(0) {}
};

bool enableVT() {
    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    if (hOut == INVALID_HANDLE_VALUE) return false;
    DWORD mode = 0;
    if (!GetConsoleMode(hOut, &mode)) return false;
    if ((mode & ENABLE_VIRTUAL_TERMINAL_PROCESSING) == 0) {
        if (!SetConsoleMode(hOut, mode | ENABLE_VIRTUAL_TERMINAL_PROCESSING)) return false;
    }
    return true;
}

//회전
char getCell(int type, int rot, int r, int c) {
    int size = 4;
    int r2 = (rot == 0) ? r : (rot == 1) ? c : (rot == 2) ? size - 1 - r : size - 1 - c;
    int c2 = (rot == 0) ? c : (rot == 1) ? size - 1 - r : (rot == 2) ? size - 1 - c : r;
    return SHAPES[type][r2][c2];
}

bool canMove(const vector<string>& board, const Piece& p, int dx, int dy, int nextRot = -1) {
    int rot = (nextRot == -1) ? p.rot : nextRot % 4;

    for (int r = 0; r < p.size; ++r) {
        for (int c = 0; c < p.size; ++c) {
            if (getCell(p.type, rot, r, c) == '#') {
                int nx = p.x + c + dx;
                int ny = p.y + r + dy;

                if (nx < 0 || nx >= W || ny < 0 || ny >= H) return false;
                if (board[ny][nx] != '.') return false;
            }
        }
    }
    return true;
}

void lockPiece(vector<string>& board, const Piece& p) {
    for (int r = 0; r < p.size; ++r)
        for (int c = 0; c < p.size; ++c)
            if (getCell(p.type, p.rot, r, c) == '#') {
                int xx = p.x + c;
                int yy = p.y + r;
                if (0 <= xx && xx < W && 0 <= yy && yy < H)
                    board[yy][xx] = '#';
            }
}

//  줄 하나 제거 시 100점씩 증가
int clearLines(vector<string>& board) {
    int addScore = 0;

    for (int y = H - 1; y >= 0; --y) {
        if (board[y].find('.') == string::npos) {
            for (int row = y; row > 0; --row)
                board[row] = board[row - 1];

            board[0] = string(W, '.');

            ++y;
            addScore += 100;
        }
    }
    return addScore;
}

Piece spawnRandomPiece() {
    return Piece(rand() % 7);
}

vector<string> composeFrame(const vector<string>& board, const Piece& p) {
    vector<string> buf = board;
    for (int r = 0; r < p.size; ++r)
        for (int c = 0; c < p.size; ++c)
            if (getCell(p.type, p.rot, r, c) == '#') {
                int xx = p.x + c;
                int yy = p.y + r;
                if (0 <= xx && xx < W && 0 <= yy && yy < H)
                    buf[yy][xx] = '#';
            }
    return buf;
}

void drawFrame(const vector<string>& buf, int score) {
    cout << "\x1b[H";
    cout << "Score: " << score << "\n";
    cout << "+" << string(W, '-') << "+\n";
    for (int r = 0; r < H; ++r)
        cout << "|" << buf[r] << "|\n";
    cout << "+" << string(W, '-') << "+\n";
    cout.flush();
}

void showGameOver() {
    cout << "\x1b[H";
    cout << "\n===== GAME OVER =====\n";
    cout << "Press any key to restart...\n";
    cout.flush();
    _getch();
}

int main() {
    srand((unsigned)time(nullptr));
    enableVT();

start_game:
    cout << "\x1b[2J\x1b[H";
    cout << "\x1b[?25l";

    vector<string> board(H, string(W, '.'));
    Piece piece = spawnRandomPiece();

    int score = 0;
    int fallMs = 400;

    auto lastFall = chrono::steady_clock::now();

    while (true) {
        auto now = chrono::steady_clock::now();

        // ───────────────────────── 입력 처리 ─────────────────────────
        if (_kbhit()) {
            int ch = _getch(); 
            if (ch == 0 || ch == 224) ch = _getch(); 
            if (ch == 75) { // 왼쪽
                if (canMove(board, piece, -1, 0)) piece.x--;
            }
            else if (ch == 77) { // 오른쪽
                if (canMove(board, piece, 1, 0)) piece.x++;
            }
            else if (ch == 80) { // 아래
                if (canMove(board, piece, 0, 1)) piece.y++;
            }
            else if (ch == 'z' || ch == 'Z') { // 반시계
                int nextRot = (piece.rot + 3) % 4;
                if (canMove(board, piece, 0, 0, nextRot)) piece.rot = nextRot;
            }
            else if (ch == 'x' || ch == 'X') { // 시계
                int nextRot = (piece.rot + 1) % 4;
                if (canMove(board, piece, 0, 0, nextRot)) piece.rot = nextRot;
            }
        }

        // ───────────────────────── 낙하 처리 ─────────────────────────
        if (chrono::duration_cast<chrono::milliseconds>(now - lastFall).count() >= fallMs) {
            if (canMove(board, piece, 0, 1)) {
                piece.y++;
            }
            else {
                lockPiece(board, piece);

                // 줄 제거 후 점수 증가
                int add = clearLines(board);
                score += add;

                // 점수에 따라 속도 증가
                fallMs = max(80, 400 - score / 5);

                // 새 블록 생성
                piece = spawnRandomPiece();

                // 게임오버 체크
                if (!canMove(board, piece, 0, 0)) {
                    showGameOver();
                    goto start_game;
                }
            }

            lastFall = now;
        }

        // ───────────────────────── 렌더링 ─────────────────────────
        drawFrame(composeFrame(board, piece), score);
        this_thread::sleep_for(chrono::milliseconds(16));
    }

    cout << "\x1b[?25h";
    return 0;
}
